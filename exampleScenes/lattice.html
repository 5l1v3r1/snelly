

<body onload="onLoad();">

<?/* ----------- @todo: embed CSS here, no external file ------------*/?>
 <head>
<link rel="stylesheet" type="text/css" href="snelly.css">
</head>

<div id="container">
    <div id="webglContainer"></div> <canvas id="render-canvas"></canvas>
    <div id="textContainer"><canvas id="text-canvas"></canvas></div>  
</div>

<?/* ----------- @todo: minify into a single monolithic JS file ------------*/?>
<?/* -----------    - this is the snelly "lib", which is bundled with each scene ------------*/?>
<?/* -----------    - can compile and version this lib                           ------------*/?>

<script type="text/javascript" src="js/thirdparty/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/three.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/libs/stats.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/libs/dat.gui.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/controls/OrbitControls.js"></script>

<script type="text/javascript" src="js/gl.js"></script>
<script type="text/javascript" src="js/gui.js"></script>
<script type="text/javascript" src="js/shaders.js"></script>
<script type="text/javascript" src="js/color.js"></script>
<script type="text/javascript" src="js/materials.js"></script>
<script type="text/javascript" src="js/spectra.js"></script>
<script type="text/javascript" src="js/pathtracer.js"></script>
<script type="text/javascript" src="js/snelly.js"></script>


<?/* ------------------------------------------------------------------*/?>
<?/*                         scene definition                          */?>
<?/* ------------------------------------------------------------------*/?>

<script type="text/javascript">

	function Scene() 
	{
		// Optional name and description
		this.name = "Menger sponge";
		this.desc = "A basic fractal form";

		// initial scene parameters
		this.parameters = {}
		this.parameters.iterations = 4;
		this.parameters.rotate = 0.0;
		this.parameters.scale = 1.0;

		this.parameters.shapes = ['Sphere', 'Cube', 'Octahedron', 'Dodecahedron', 'Icosahedron', 
								'TruncatedOctahedron', 'TruncatedIcosahedron'];
		this.parameters.shape = 'Sphere';
		this.parameters.size = 4.0;
		this.parameters.spacing = 10.0;
		this.parameters.width = 5.0;
		this.parameters.height = 5.0;
		this.parameters.depth = 5.0;
		this.parameters.offset = 0.0;
		this.parameters.bulge = 0.25;
	}

	// Optional name and description 
	Scene.prototype.getName = function() { return "Menger sponge"; }
	Scene.prototype.getDesc = function() { return "A basic fractal form"; }

	// This function must specify at least one of the three functions:
	//      float SDF_METAL(vec3 X);
	//      float SDF_DIELECTRIC(vec3 X);
	//      float SDF_DIFFUSE(vec3 X);
	// (If only one or two are present, the others will not be rendered)
	Scene.prototype.sdf = function()
	{
		// Note that in this case, changing this.parameters.iterations requires a recompile,
		// whereas changing the other parameters doesn't.

		var func = '';
		var ret = '';
		if (this.parameters.bulge < 1.0e-6)
		{
			func = `d = max(d, abs(dot(p, GDFVectors[i])))`;
			ret = `d - r`;
		}
		else
		{
			this.parameters.bulge = Math.max(this.parameters.bulge, 0.05);
			func = `d += pow(abs(dot(p, GDFVectors[i])), 1.0/max(e, 1.0e-6))`;
			ret = `pow(d, e) - r`;
		}

		return `

			/////////////////////////////////////////////////////////////////////////////////////
			// Shader code
			/////////////////////////////////////////////////////////////////////////////////////

				uniform float _size;
				uniform float _spacing;
				uniform float _width; 
				uniform float _height;
				uniform float _depth; 
				uniform float _offset;
				uniform float _bulge;        

				// Uses code from HG_SDF library, http://mercury.sexy/hg_sdf/ 
				uniform vec3 GDFVectors[19];

				float sdOctahedron(vec3 p, float r, float e) {
					float d = 0.0;
					for (int i = 3; i <= 6; ++i) ${func};
					return ${ret};
				}

				float sdDodecahedron(vec3 p, float r, float e) {
					float d = 0.0;
					for (int i = 13; i <= 18; ++i) ${func};
					return ${ret};
				}

				float sdIcosahedron(vec3 p, float r, float e) {
					float d = 0.0;
					for (int i = 3; i <= 12; ++i) ${func};
					return ${ret};
				}

				float sdTruncatedOctahedron(vec3 p, float r, float e) {
					float d = 0.0;
					for (int i = 0; i <= 6; ++i) ${func};
					return ${ret};
				}

				float sdTruncatedIcosahedron(vec3 p, float r, float e) {
					float d = 0.0;
					for (int i = 3; i <= 18; ++i) ${func};
					return ${ret};
				}

				float sdSphere(vec3 X, float r, float e)                  
				{                                     
					return length(X) - r;       
				}      

				float sdCube(vec3 X, float r, float e)               
				{                                   
					vec3 d = abs(X) - vec3(r,r,r);
					return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));           
				}  

				float sdBox(vec3 X, vec3 bounds)                     
				{                                     
				    vec3 d = abs(X) - bounds;
				    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));     
				} 

				float sdBox(vec3 X, vec3 bmin, vec3 bmax)                     
				{                            
					vec3 center = 0.5*(bmin + bmax);
					vec3 halfExtents = 0.5*(bmax - bmin);         
					vec3 d = abs(X-center) - halfExtents;
					return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));     
				} 

				float lattice(vec3 X, float c)
				{
					vec3 r = 0.5*vec3(c,c,c);
					vec3 q = mod(X-(1.0-_offset)*r, c) - r;
					return sd${this.parameters.shape}(q, _size, _bulge/5.0);
				}

				float opI( float d1, float d2 ) { return max(d1,d2); }


				float SDF_DIELECTRIC(vec3 X)                     
				{
					return opI( sdBox(X, vec3(_width, _height, _depth)), 
								lattice(X, _spacing) );
				}     


			uniform float _rotate;
			uniform float _scale;
			#define TWOPI 6.28318530718

			vec2 rotate(vec2 v, float a) 
			{
			 	return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y); 
			}

			float sdCross( in vec3 p )
			{
				float inf = 1.0e6;
				float da = sdBox(p.xyz, vec3(inf,1.0,1.0));
				float db = sdBox(p.yzx, vec3(1.0,inf,1.0));
				float dc = sdBox(p.zxy, vec3(1.0,1.0,inf));
				return min(da,min(db,dc));
			}

			float menger(vec3 X) 
			{
				float sd = sdBox(X, vec3(1.0));
				float scale = _scale;
				const int iter = ${Math.floor(this.parameters.iterations)};
				for (int i=0; i<iter; i++) 
				{
					X.xy = rotate(X.xy, 2.0*sin(TWOPI*_rotate));
					vec3 a = mod(X*scale, 2.0)-1.0;
					scale *= 3.0;
					vec3 r = abs(1.0 - 3.0*abs(a));
					float da = max(r.x,r.y);
					float db = max(r.y,r.z);
					float dc = max(r.z,r.x);
					float c = (min(da,min(db,dc))-1.0)/scale;
					sd = max(sd, c);
				}
				return sd;
			}	

			float SDF_METAL(vec3 X)
			{
				return menger(X);
			}

		
			////////////////////////////////////////////////////////////////////// end of shader code
		`;
	}

  
  // Called whenever this scene UI was switched to, or changed while active,
  // and syncs the params of the shader to the current UI settings
  Scene.prototype.syncShader = function(shader)
  {
		shader.uniform3Fv("GDFVectors", this.GDFVectorsFlattened);

		shader.uniformF("_size", this.parameters.size);
		shader.uniformF("_bulge", this.parameters.bulge);
		shader.uniformF("_spacing", this.parameters.spacing);
		shader.uniformF("_width",  this.parameters.width);
		shader.uniformF("_height", this.parameters.height);
		shader.uniformF("_depth",  this.parameters.depth);
		shader.uniformF("_offset",  this.parameters.offset);

		// (The shader parameter names here must be consistent with the GLSL sdf code defined above)
		shader.uniformF("_rotate", this.parameters.rotate);
		shader.uniformF("_scale", this.parameters.scale);
		shader.uniformF("_scaleWidth", this.parameters.scaleWidth);
		shader.uniformF("_scaleHeight", this.parameters.scaleHeight);
  }

  // Gives the raytracer some indication of (rough) scene size, so it
  // can set tolerances appropriately.
  Scene.prototype.getScale = function()
  {
		return 1.0;
  }

  // Initial cam position default for this scene
  Scene.prototype.init = function(controls, camera, laser)
  {
  		// Use key 'C' to dump the code below for the current cam position to the console.
		controls.target.set(2.01584, -0.603169, -0.808580);
		camera.position.set(-4.81888, 2.39746, 3.47067);

		var PHI = Math.sqrt(5.0)*0.5 + 0.5;

		var GDFVectors = [];
		GDFVectors.push(new THREE.Vector3(1, 0, 0).normalize());
		GDFVectors.push(new THREE.Vector3(0, 1, 0).normalize());
		GDFVectors.push(new THREE.Vector3(0, 0, 1).normalize());
		GDFVectors.push(new THREE.Vector3(1, 1, 1).normalize());
		GDFVectors.push(new THREE.Vector3(-1, 1, 1).normalize());
		GDFVectors.push(new THREE.Vector3(1, -1, 1).normalize());
		GDFVectors.push(new THREE.Vector3(1, 1, -1).normalize());
		GDFVectors.push(new THREE.Vector3(0, 1, PHI+1.0).normalize());
		GDFVectors.push(new THREE.Vector3(0, -1, PHI+1.0).normalize());
		GDFVectors.push(new THREE.Vector3(PHI+1.0, 0, 1).normalize());
		GDFVectors.push(new THREE.Vector3(-PHI-1.0, 0, 1).normalize());
		GDFVectors.push(new THREE.Vector3(1, PHI+1.0, 0).normalize());
		GDFVectors.push(new THREE.Vector3(-1, PHI+1.0, 0).normalize());
		GDFVectors.push(new THREE.Vector3(0, PHI, 1).normalize());
		GDFVectors.push(new THREE.Vector3(0, -PHI, 1).normalize());
		GDFVectors.push(new THREE.Vector3(1, 0, PHI).normalize());
		GDFVectors.push(new THREE.Vector3(-1, 0, PHI).normalize());
		GDFVectors.push(new THREE.Vector3(PHI, 1, 0).normalize());
		GDFVectors.push(new THREE.Vector3(-PHI, 1, 0).normalize());

		this.GDFVectorsFlattened = [];
		for (var n=0; n<GDFVectors.length; n++) 
		{
			var v = GDFVectors[n];
			this.GDFVectorsFlattened.push(v.x);
			this.GDFVectorsFlattened.push(v.y);
			this.GDFVectorsFlattened.push(v.z);
		}
  }

  // set up gui and callbacks for this scene
  Scene.prototype.initGui = function(gui)            
  {
	  	this.typeItem = gui.getSceneFolder().add(this.parameters, 'shape', this.parameters.shapes);
		this.typeItem.onChange( function(value) { snelly.reset(); } );

	  	gui.addParameter(this.parameters, {name: 'size', min: 0.0, max: 10.0});
		gui.addParameter(this.parameters, {name: 'bulge', min: 0.0, max: 1.0});
		gui.addParameter(this.parameters, {name: 'spacing', min: 0.0, max: 50.0});
		gui.addParameter(this.parameters, {name: 'width', min: 0.0, max: 100.0});
		gui.addParameter(this.parameters, {name: 'height', min: 0.0, max: 100.0});
		gui.addParameter(this.parameters, {name: 'depth', min: 0.0, max: 100.0});
		gui.addParameter(this.parameters, {name: 'offset', min: 0.0, max: 1.0});

  		// (iterations cannot be a shader uniform, so recompilation required on a change in that parameter)
  		gui.addParameter(this.parameters, {name: 'iterations', min: 1, max: 8, step: 1, recompile: true}); 
  		gui.addParameter(this.parameters, {name: 'rotate',     min: 0.0, max: 1.0}); 
  		gui.addParameter(this.parameters, {name: 'scale',      min: 0.0, max: 10.0});
  }

  // optionally supply an env-map texture URL (should be lat-long)
  Scene.prototype.envMap = function()
  {
	  	return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_041_Path_Bg.jpg';
	  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/74e9d389/HDR_040_Field_Bg.jpg';
	  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/74e9d389/HDR_112_River_Road_2_Bg.jpg';
	  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_110_Tunnel_Bg.jpg';
	  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_Free_City_Night_Lights_Bg.jpg';
  }

</script>


<?/* -----------------------------------------------------------------*/?>

<script type="text/javascript">

// Snelly object
var snelly;

// shim layer with setTimeout fallback
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function( callback ){
            window.setTimeout(callback, 1000/60);
          };
})();

function onLoad()
{
	console.log('on load');
	
	// Instantiate Snelly
	snelly = new Snelly(new Scene());
	
	// Begin rendering
	animateLoop();
}

function animateLoop() 
{
	snelly.render();
	window.requestAnimFrame(animateLoop);
}

</script>
</body>


