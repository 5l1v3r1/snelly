

<body onload="onLoad();">

<?/* ----------- do not modify ------------*/?>
<?/* ----------- @todo: embed CSS here, no external file ------------*/?>
 <head>
<link rel="stylesheet" type="text/css" href="snelly.css">
</head>

<div id="container">
    <div id="webglContainer"></div> <canvas id="render-canvas"></canvas>
    <div id="textContainer"><canvas id="text-canvas"></canvas></div>  
</div>

<script type="text/javascript" src="js/thirdparty/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/three.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/libs/stats.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/libs/dat.gui.min.js"></script>
<script type="text/javascript" src="js/thirdparty/three/controls/OrbitControls.js"></script>

<script type="text/javascript" src="js/gl.js"></script>
<script type="text/javascript" src="js/gui.js"></script>
<script type="text/javascript" src="js/shaders.js"></script>
<script type="text/javascript" src="js/color.js"></script>
<script type="text/javascript" src="js/materials.js"></script>
<script type="text/javascript" src="js/spectra.js"></script>
<script type="text/javascript" src="js/pathtracer.js"></script>
<script type="text/javascript" src="js/snelly.js"></script>


<?/* ------------------------------------------------------------------*/?>
<?/*                         scene definition                          */?>
<?/* ------------------------------------------------------------------*/?>

<script type="text/javascript">

function Scene() {}

/////////////////////////////////////////////////////////////////////////////////
// Scene state initialization
/////////////////////////////////////////////////////////////////////////////////

// Optionally, provide this function which generates the init code to re-generate 
// the current parameter settings. This will be dumped to the console (along with 
// the rest of the UI state) on pressing key 'O', allowing scene user-parameter 
// state to be tweaked in the UI then saved by copy-pasting into the init function.
Scene.prototype.initGenerator = function()
{
	return `
this.parameters = {};
this.parameters.foo = ${this.parameters.foo};
this.parameters.bar = ${this.parameters.bar};
this.frame = 0;
	`; 
}

Scene.prototype.init = function(snelly)
{
	let renderer  = snelly.getRenderer();
	let camera    = snelly.getCamera();
	let controls  = snelly.getControls();
	let materials = snelly.getMaterials();

	////////////////// copy-pasted console output on 'O', begin /////////////////////

	this.parameters = {};
	this.parameters.foo = 0.7892882311486962;
	this.parameters.bar = 0;
	this.frame = 0;
	snelly.showGUI(false);

	// Camera settins:
	// 		camera is a THREE.PerspectiveCamera object
	// 		controls is a THREE.OrbitControls object
	camera.fov = 45;
	camera.up.set(0, 1, 0);
	//camera.lookAt(new THREE.Vector3(-0.013661883756091644, -0.22754946350020774, -0.9736706757985236));
	camera.position.set(0.011622464934610664, 0.475561534689623, 1.640799247002282);
	controls.target.set(-0.011902128678671532, 0.08374086084009465, -0.03577825319842449);
	controls.zoomSpeed = 2;
	controls.keyPanSpeed = 100;

	// Renderer settings
	renderer.renderMode = 'ao';  // The other modes are: 'ao', 'normals'
	renderer.maxBounces = 3;
	renderer.maxMarchSteps = 174;
	renderer.radianceClamp = 3; // (log scale)
	renderer.skyPower = 6.314305849189569;
	renderer.skyTemperature = 6000;
	renderer.exposure = 5.637773079633545;
	renderer.gamma = 1.6913319238900635;
	renderer.whitepoint = 2;
	renderer.goalFrametimeMs = 60;

	// Material settings
	let surface = materials.loadSurface();
	surface.roughness = 0.001127554615926709;
	surface.ior = 1.3530655391120507;
	surface.diffuseAlbedo = [0.23529411764705888, 0.0807381776239908, 0.0807381776239908];
	surface.specAlbedo = [0.11764705882352944, 0.11764705882352944, 0.11764705882352944];

	let dielectric = materials.loadDielectric('Glass (K7)');
	dielectric.absorptionColor = [1, 0.9411764705882353, 0.9411764705882353];
	dielectric.absorptionScale = 0.17; // mfp in multiples of scene scale
	dielectric.roughness = 0.004510218463706836;

	let metal = materials.loadMetal('Gold');
	metal.roughness = 0.05;

	////////////////// copy-pasted console output on 'O', end /////////////////////
}


// Optionally, supply an env-map texture URL (must be a lat-long format image).
// (If this is function not implemented, or it returns the empty string, a uniform
// temperature blackbody sky is used).
Scene.prototype.envMap = function()
{
  	return 'https://cdn.rawgit.com/portsmouth/envmaps/74e9d389/HDR_040_Field_Bg.jpg';
  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_041_Path_Bg.jpg';
  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/74e9d389/HDR_112_River_Road_2_Bg.jpg';
  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_110_Tunnel_Bg.jpg';
  	//return 'https://cdn.rawgit.com/portsmouth/envmaps/7405220b/HDR_Free_City_Night_Lights_Bg.jpg';
}


// Optional name and description 
Scene.prototype.getName = function() { return "Hello world"; }
Scene.prototype.getDesc = function() { return "A simple example"; }


/////////////////////////////////////////////////////////////////////////////////////
// Shader code
/////////////////////////////////////////////////////////////////////////////////////

// This function is mandatory!
Scene.prototype.shader = function()
{
	return `
		uniform float _foo;
		uniform float _bar;

		#define TWOPI 6.28318530718

		vec2 rotate(vec2 v, float a) 
		{
		 	return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y); 
		}

		float sdBox(vec3 X, vec3 bounds)                     
		{                                     
		    vec3 d = abs(X) - bounds;
		    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));     
		} 

		float sdCross( in vec3 p )
		{
			float inf = 1.0e6;
			float da = sdBox(p.xyz, vec3(inf,1.0,1.0));
			float db = sdBox(p.yzx, vec3(1.0,inf,1.0));
			float dc = sdBox(p.zxy, vec3(1.0,1.0,inf));
			return min(da,min(db,dc));
		}

		float menger(vec3 X) 
		{
			float _rotate = 30.0;
			float sd = sdBox(X, vec3(1.0));
			float scale = 1.0;;
			const int iter = 3;
			for (int i=0; i<iter; i++) 
			{
				X.xy = rotate(X.xy, 2.0*sin(TWOPI*_rotate));
				vec3 a = mod(X*scale, 2.0)-1.0;
				scale *= 3.0;
				vec3 r = abs(1.0 - 3.0*abs(a));
				float da = max(r.x,r.y);
				float db = max(r.y,r.z);
				float dc = max(r.z,r.x);
				float c = (min(da,min(db,dc))-1.0)/scale;
				sd = max(sd, c);
			}
			return sd;
		}	

		float sdSphere(vec3 X, float r)                  
		{                                     
			return length(X) - r;       
		}   

		float sdBox(vec3 X, vec3 bmin, vec3 bmax)                     
		{                            
			vec3 center = 0.5*(bmin + bmax);
			vec3 halfExtents = 0.5*(bmax - bmin);         
			vec3 d = abs(X-center) - halfExtents;
			return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));     
		} 

		// Union
		float opU( float d1, float d2 ) { return min(d1,d2); }

		// Subtraction
		float opS(float A, float B) { return max(-B, A); }

		// Intersection
		float opI( float d1, float d2 ) { return max(d1,d2); }



		// Any of the user-defined functions below can be omitted, in which case it will be
		// replaced with the default indicated.
		// Note that the reflectances can be treated as [0,1] RGB values in sRGB color space.


		//////////////////////////////////////////////////////
		// Surface
		//////////////////////////////////////////////////////

		float SDF_SURFACE(in vec3 X)                     
		{
			vec3 bmin = vec3(-100.0, -1.0, -100.0);
			vec3 bmax = vec3( 100.0,  0.0,  100.0);
			float floor = sdBox(X, bmin, bmax);

			return opU(floor, opI(sdSphere(X, _foo), menger(X)));
		}  

		// space-varying multiplier to the UI-exposed color (defaults to vec3(1.0))
		vec3 SURFACE_DIFFUSE_REFLECTANCE(in vec3 X)
		{
			float ax = 1.0 - pow(0.5*(1.0 + cos(50.0*X.x)), 100.0);
			float ay = 1.0 - pow(0.5*(1.0 + cos(50.0*X.z)), 100.0);
			float albedo = ax*ay;
		    return vec3(albedo);
		}

		// space-varying multiplier to the UI-exposed color (defaults to vec3(1.0))
		vec3 SURFACE_SPECULAR_REFLECTANCE(in vec3 X)
		{
		    return vec3(1.0);
		}

		// space-varying multiplier to the UI-exposed constant (defaults to 1.0)
		float SURFACE_IOR(in vec3 X)
		{
		    return 1.0;
		}

		// space-varying multiplier to the UI-exposed constant (defaults to 1.0)
		float SURFACE_ROUGHNESS(in vec3 X)
		{
		    return 1.0;
		}


		//////////////////////////////////////////////////////
		// Metal
		//////////////////////////////////////////////////////   
		
		float SDF_METAL(in vec3 X)                     
		{	
			 return 1.0e6;//0.5*menger(X*0.5-vec3(1.0));
		} 

		// space-varying multiplier to the UI-exposed color (defaults to vec3(1.0))
		vec3 METAL_SPECULAR_REFLECTANCE(in vec3 X)
		{
		    return vec3(1.0, 1.0, 1.0);
		}

		// space-varying multiplier to the UI-exposed constant (defaults to 1.0)
		float METAL_ROUGHNESS(in vec3 X)
		{
		    return 1.0;
		}


		//////////////////////////////////////////////////////
		// Dielectric
		//////////////////////////////////////////////////////   
		
		float SDF_DIELECTRIC(vec3 X)                     
		{
		    return sdSphere(X, _bar);
		}  

		// space-varying multiplier to the UI-exposed color (defaults to vec3(1.0))
		vec3 DIELECTRIC_SPECULAR_REFLECTANCE(in vec3 X)
		{
		    return vec3(1.0, 1.0, 1.0);
		}

		// space-varying multiplier to the UI-exposed constant (defaults to 1.0)
		float DIELECTRIC_ROUGHNESS(in vec3 X)
		{
		    return 1.0;
		}


		////////////////////////////////////////////////////////////////////// end of shader code
	`;
}


// Optional. Set up gui and callbacks for this scene
Scene.prototype.initGui = function(gui)            
{
  	gui.addParameter(this.parameters, {name: 'foo', min: 0.0, max: 1.0});
  	gui.addParameter(this.parameters, {name: 'bar', min: 0.0, max: 1.0});
}

// Optional. Called whenever the UI is changed,
// and must sync the params of the shader with the current UI settings
Scene.prototype.syncShader = function(shader)
{
	shader.uniformF("_foo", this.parameters.foo);
	shader.uniformF("_bar", this.parameters.bar);
}

// Optional. Gives the raytracer some indication of the (rough) scene length scale, 
// so it can set tolerances appropriately. Note, the raymarcher will march no further
// from the camera than 100 times this scale, and the smallest resolvable structure 
// is about 1.0e-5 this scale.
Scene.prototype.getScale = function()
{
	return 1.0;
}


//////////////////////////////////////////////////////////////////////////////////
// Callbacks
//////////////////////////////////////////////////////////////////////////////////

// Optional callback before every frame
Scene.prototype.preframeCallback = function(snelly, gl)
{
	let renderer  = snelly.getRenderer();
	let camera    = snelly.getCamera();
	let controls  = snelly.getControls();
	let materials = snelly.getMaterials();
	let gui       = snelly.getGUI();

	if (this.frame==0)
	{
		this.axisProj = new THREE.Vector3();
		this.axisPerp = new THREE.Vector3();

		let targetToCam = new THREE.Vector3();
		targetToCam.copy(camera.position).sub(controls.target);

		let axis = camera.up;
		this.axisProj.copy(controls.target);
		this.axisProj.addScaledVector(axis, axis.dot(targetToCam));
		this.axisPerp.copy(targetToCam).sub(this.axisProj);
	}

	// Can implement animation rendering logic here
	// to update scene programmatically according to global time since init
	let FPS = 24.0;
	let time = this.frame/FPS;
	let period = 10.0;
	this.endFrame = period * FPS;
	
	if (renderer.spp >= 100.0)
	{	
		// animate camera	
		let phase = 2.0*Math.PI*time/period;

		// code to orbit around current target at the same azimuth and radius:
		let rot = new THREE.Quaternion();
		let axis = camera.up;
		rot.setFromAxisAngle(axis, phase);
		let newAxisPerp = new THREE.Vector3();
		newAxisPerp.copy(this.axisPerp);
		newAxisPerp.applyQuaternion(rot);
		
		let newCamPos = new THREE.Vector3();
		newCamPos.copy(controls.target);
		newCamPos.add(this.axisProj);
		newCamPos.add(newAxisPerp);
		camera.position.copy(newCamPos);
		controls.update();

		// animate user scene parameters
		this.parameters.foo = Math.abs(Math.sin(phase));
		this.parameters.bar = 0.5*Math.abs(Math.cos(phase));

		// animate materials
		let surface = materials.getSurface();
		surface.diffuseAlbedo = [phase, 0.1, 1.0-phase];
		gui.sync();

		let no_recompile = true;
		let reinit = false;
		renderer.reset(no_recompile, reinit);

		this.frame++;
	}
}


// Optional callback after every frame
Scene.prototype.postframeCallback = function(snelly, gl)
{
	let renderer  = snelly.getRenderer();
	
	// User code to post webGL framebuffer data to local server for processing
	if (this.frame>0 && renderer.spp >= 100.0 && this.frame<=this.endFrame)
	{
		let dataURI = gl.canvas.toDataURL();

		var mimetype = dataURI.split(",")[0].split(':')[1].split(';')[0];
		var byteString = atob(dataURI.split(',')[1]);
		var u8a = new Uint8Array(byteString.length);
		for (var i = 0; i < byteString.length; i++) 
		{
			u8a[i] = byteString.charCodeAt(i);
		}
		let blob = new Blob([u8a.buffer], { type: mimetype });

		let r = new XMLHttpRequest();
		r.open('POST', 'http://localhost:3999/' + this.frame, false);
		r.send(blob);
	}
}

</script>



<?/* -----------------------------------------------------------------*/?>

<script type="text/javascript">

// Snelly object
var snelly;

// shim layer with setTimeout fallback
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function( callback ){
            window.setTimeout(callback, 1000/60);
          };
})();

function onLoad()
{
	snelly = new Snelly(new Scene());
	animateLoop();
}

function animateLoop() 
{
	snelly.render();
	window.requestAnimFrame(animateLoop);
}

</script>
</body>


